// Code generated by protoc-gen-gogo.
// source: fuzz3.proto
// DO NOT EDIT!

package fuzztests

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TheTestEnum3 int32

const (
	TheTestEnum3_D TheTestEnum3 = 0
	TheTestEnum3_E TheTestEnum3 = 1
	TheTestEnum3_F TheTestEnum3 = 2
)

var TheTestEnum3_name = map[int32]string{
	0: "D",
	1: "E",
	2: "F",
}
var TheTestEnum3_value = map[string]int32{
	"D": 0,
	"E": 1,
	"F": 2,
}

func (x TheTestEnum3) String() string {
	return proto.EnumName(TheTestEnum3_name, int32(x))
}

type NestedDefinition3_NestedEnum3 int32

const (
	NestedDefinition3_TYPE_NESTED3 NestedDefinition3_NestedEnum3 = 0
	NestedDefinition3_TYPE_NESTE3  NestedDefinition3_NestedEnum3 = 1
)

var NestedDefinition3_NestedEnum3_name = map[int32]string{
	0: "TYPE_NESTED3",
	1: "TYPE_NESTE3",
}
var NestedDefinition3_NestedEnum3_value = map[string]int32{
	"TYPE_NESTED3": 0,
	"TYPE_NESTE3":  1,
}

func (x NestedDefinition3_NestedEnum3) String() string {
	return proto.EnumName(NestedDefinition3_NestedEnum3_name, int32(x))
}

type NinOptNative3 struct {
	Field1  float64 `protobuf:"fixed64,1,opt,name=Field1,proto3" json:"Field1,omitempty"`
	Field2  float32 `protobuf:"fixed32,2,opt,name=Field2,proto3" json:"Field2,omitempty"`
	Field3  int32   `protobuf:"varint,3,opt,name=Field3,proto3" json:"Field3,omitempty"`
	Field4  int64   `protobuf:"varint,4,opt,name=Field4,proto3" json:"Field4,omitempty"`
	Field5  uint32  `protobuf:"varint,5,opt,name=Field5,proto3" json:"Field5,omitempty"`
	Field6  uint64  `protobuf:"varint,6,opt,name=Field6,proto3" json:"Field6,omitempty"`
	Field7  int32   `protobuf:"zigzag32,7,opt,name=Field7,proto3" json:"Field7,omitempty"`
	Field8  int64   `protobuf:"zigzag64,8,opt,name=Field8,proto3" json:"Field8,omitempty"`
	Field9  uint32  `protobuf:"fixed32,9,opt,name=Field9,proto3" json:"Field9,omitempty"`
	Field10 int32   `protobuf:"fixed32,10,opt,name=Field10,proto3" json:"Field10,omitempty"`
	Field11 uint64  `protobuf:"fixed64,11,opt,name=Field11,proto3" json:"Field11,omitempty"`
	Field12 int64   `protobuf:"fixed64,12,opt,name=Field12,proto3" json:"Field12,omitempty"`
	Field13 bool    `protobuf:"varint,13,opt,name=Field13,proto3" json:"Field13,omitempty"`
	Field14 string  `protobuf:"bytes,14,opt,name=Field14,proto3" json:"Field14,omitempty"`
	Field15 []byte  `protobuf:"bytes,15,opt,name=Field15,proto3" json:"Field15,omitempty"`
}

func (m *NinOptNative3) Reset()         { *m = NinOptNative3{} }
func (m *NinOptNative3) String() string { return proto.CompactTextString(m) }
func (*NinOptNative3) ProtoMessage()    {}

type NinRepNative3 struct {
	Field1  []float64 `protobuf:"fixed64,1,rep,name=Field1" json:"Field1,omitempty"`
	Field2  []float32 `protobuf:"fixed32,2,rep,name=Field2" json:"Field2,omitempty"`
	Field3  []int32   `protobuf:"varint,3,rep,name=Field3" json:"Field3,omitempty"`
	Field4  []int64   `protobuf:"varint,4,rep,name=Field4" json:"Field4,omitempty"`
	Field5  []uint32  `protobuf:"varint,5,rep,name=Field5" json:"Field5,omitempty"`
	Field6  []uint64  `protobuf:"varint,6,rep,name=Field6" json:"Field6,omitempty"`
	Field7  []int32   `protobuf:"zigzag32,7,rep,name=Field7" json:"Field7,omitempty"`
	Field8  []int64   `protobuf:"zigzag64,8,rep,name=Field8" json:"Field8,omitempty"`
	Field9  []uint32  `protobuf:"fixed32,9,rep,name=Field9" json:"Field9,omitempty"`
	Field10 []int32   `protobuf:"fixed32,10,rep,name=Field10" json:"Field10,omitempty"`
	Field11 []uint64  `protobuf:"fixed64,11,rep,name=Field11" json:"Field11,omitempty"`
	Field12 []int64   `protobuf:"fixed64,12,rep,name=Field12" json:"Field12,omitempty"`
	Field13 []bool    `protobuf:"varint,13,rep,name=Field13" json:"Field13,omitempty"`
	Field14 []string  `protobuf:"bytes,14,rep,name=Field14" json:"Field14,omitempty"`
	Field15 [][]byte  `protobuf:"bytes,15,rep,name=Field15" json:"Field15,omitempty"`
}

func (m *NinRepNative3) Reset()         { *m = NinRepNative3{} }
func (m *NinRepNative3) String() string { return proto.CompactTextString(m) }
func (*NinRepNative3) ProtoMessage()    {}

type NinRepPackedNative3 struct {
	Field1  []float64 `protobuf:"fixed64,1,rep,packed,name=Field1" json:"Field1,omitempty"`
	Field2  []float32 `protobuf:"fixed32,2,rep,packed,name=Field2" json:"Field2,omitempty"`
	Field3  []int32   `protobuf:"varint,3,rep,packed,name=Field3" json:"Field3,omitempty"`
	Field4  []int64   `protobuf:"varint,4,rep,packed,name=Field4" json:"Field4,omitempty"`
	Field5  []uint32  `protobuf:"varint,5,rep,packed,name=Field5" json:"Field5,omitempty"`
	Field6  []uint64  `protobuf:"varint,6,rep,packed,name=Field6" json:"Field6,omitempty"`
	Field7  []int32   `protobuf:"zigzag32,7,rep,packed,name=Field7" json:"Field7,omitempty"`
	Field8  []int64   `protobuf:"zigzag64,8,rep,packed,name=Field8" json:"Field8,omitempty"`
	Field9  []uint32  `protobuf:"fixed32,9,rep,packed,name=Field9" json:"Field9,omitempty"`
	Field10 []int32   `protobuf:"fixed32,10,rep,packed,name=Field10" json:"Field10,omitempty"`
	Field11 []uint64  `protobuf:"fixed64,11,rep,packed,name=Field11" json:"Field11,omitempty"`
	Field12 []int64   `protobuf:"fixed64,12,rep,packed,name=Field12" json:"Field12,omitempty"`
	Field13 []bool    `protobuf:"varint,13,rep,packed,name=Field13" json:"Field13,omitempty"`
}

func (m *NinRepPackedNative3) Reset()         { *m = NinRepPackedNative3{} }
func (m *NinRepPackedNative3) String() string { return proto.CompactTextString(m) }
func (*NinRepPackedNative3) ProtoMessage()    {}

type NinOptStruct3 struct {
	Field1  float64        `protobuf:"fixed64,1,opt,name=Field1,proto3" json:"Field1,omitempty"`
	Field2  float32        `protobuf:"fixed32,2,opt,name=Field2,proto3" json:"Field2,omitempty"`
	Field3  *NinOptNative3 `protobuf:"bytes,3,opt,name=Field3" json:"Field3,omitempty"`
	Field4  *NinOptNative3 `protobuf:"bytes,4,opt,name=Field4" json:"Field4,omitempty"`
	Field6  uint64         `protobuf:"varint,6,opt,name=Field6,proto3" json:"Field6,omitempty"`
	Field7  int32          `protobuf:"zigzag32,7,opt,name=Field7,proto3" json:"Field7,omitempty"`
	Field8  *NinOptNative3 `protobuf:"bytes,8,opt,name=Field8" json:"Field8,omitempty"`
	Field13 bool           `protobuf:"varint,13,opt,name=Field13,proto3" json:"Field13,omitempty"`
	Field14 string         `protobuf:"bytes,14,opt,name=Field14,proto3" json:"Field14,omitempty"`
	Field15 []byte         `protobuf:"bytes,15,opt,name=Field15,proto3" json:"Field15,omitempty"`
}

func (m *NinOptStruct3) Reset()         { *m = NinOptStruct3{} }
func (m *NinOptStruct3) String() string { return proto.CompactTextString(m) }
func (*NinOptStruct3) ProtoMessage()    {}

func (m *NinOptStruct3) GetField3() *NinOptNative3 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinOptStruct3) GetField4() *NinOptNative3 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinOptStruct3) GetField8() *NinOptNative3 {
	if m != nil {
		return m.Field8
	}
	return nil
}

type NinRepStruct3 struct {
	Field1  []float64        `protobuf:"fixed64,1,rep,name=Field1" json:"Field1,omitempty"`
	Field2  []float32        `protobuf:"fixed32,2,rep,name=Field2" json:"Field2,omitempty"`
	Field3  []*NinOptNative3 `protobuf:"bytes,3,rep,name=Field3" json:"Field3,omitempty"`
	Field4  []*NinOptNative3 `protobuf:"bytes,4,rep,name=Field4" json:"Field4,omitempty"`
	Field6  []uint64         `protobuf:"varint,6,rep,name=Field6" json:"Field6,omitempty"`
	Field7  []int32          `protobuf:"zigzag32,7,rep,name=Field7" json:"Field7,omitempty"`
	Field8  []*NinOptNative3 `protobuf:"bytes,8,rep,name=Field8" json:"Field8,omitempty"`
	Field13 []bool           `protobuf:"varint,13,rep,name=Field13" json:"Field13,omitempty"`
	Field14 []string         `protobuf:"bytes,14,rep,name=Field14" json:"Field14,omitempty"`
	Field15 [][]byte         `protobuf:"bytes,15,rep,name=Field15" json:"Field15,omitempty"`
}

func (m *NinRepStruct3) Reset()         { *m = NinRepStruct3{} }
func (m *NinRepStruct3) String() string { return proto.CompactTextString(m) }
func (*NinRepStruct3) ProtoMessage()    {}

func (m *NinRepStruct3) GetField3() []*NinOptNative3 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepStruct3) GetField4() []*NinOptNative3 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepStruct3) GetField8() []*NinOptNative3 {
	if m != nil {
		return m.Field8
	}
	return nil
}

type NinNestedStruct3 struct {
	Field1 *NinOptStruct3   `protobuf:"bytes,1,opt,name=Field1" json:"Field1,omitempty"`
	Field2 []*NinRepStruct3 `protobuf:"bytes,2,rep,name=Field2" json:"Field2,omitempty"`
}

func (m *NinNestedStruct3) Reset()         { *m = NinNestedStruct3{} }
func (m *NinNestedStruct3) String() string { return proto.CompactTextString(m) }
func (*NinNestedStruct3) ProtoMessage()    {}

func (m *NinNestedStruct3) GetField1() *NinOptStruct3 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinNestedStruct3) GetField2() []*NinRepStruct3 {
	if m != nil {
		return m.Field2
	}
	return nil
}

type Nil3 struct {
}

func (m *Nil3) Reset()         { *m = Nil3{} }
func (m *Nil3) String() string { return proto.CompactTextString(m) }
func (*Nil3) ProtoMessage()    {}

type NinOptEnum3 struct {
	Field1 TheTestEnum3 `protobuf:"varint,1,opt,name=Field1,proto3,enum=fuzztests.TheTestEnum3" json:"Field1,omitempty"`
}

func (m *NinOptEnum3) Reset()         { *m = NinOptEnum3{} }
func (m *NinOptEnum3) String() string { return proto.CompactTextString(m) }
func (*NinOptEnum3) ProtoMessage()    {}

type NinRepEnum3 struct {
	Field1 []TheTestEnum3 `protobuf:"varint,1,rep,name=Field1,enum=fuzztests.TheTestEnum3" json:"Field1,omitempty"`
}

func (m *NinRepEnum3) Reset()         { *m = NinRepEnum3{} }
func (m *NinRepEnum3) String() string { return proto.CompactTextString(m) }
func (*NinRepEnum3) ProtoMessage()    {}

type NestedDefinition3 struct {
	Field1    int64                                              `protobuf:"varint,1,opt,name=Field1,proto3" json:"Field1,omitempty"`
	EnumField NestedDefinition3_NestedEnum3                      `protobuf:"varint,2,opt,name=EnumField,proto3,enum=fuzztests.NestedDefinition3_NestedEnum3" json:"EnumField,omitempty"`
	NNM       *NestedDefinition3_NestedMessage3_NestedNestedMsg3 `protobuf:"bytes,3,opt,name=NNM" json:"NNM,omitempty"`
	NM        *NestedDefinition3_NestedMessage3                  `protobuf:"bytes,4,opt,name=NM" json:"NM,omitempty"`
}

func (m *NestedDefinition3) Reset()         { *m = NestedDefinition3{} }
func (m *NestedDefinition3) String() string { return proto.CompactTextString(m) }
func (*NestedDefinition3) ProtoMessage()    {}

func (m *NestedDefinition3) GetNNM() *NestedDefinition3_NestedMessage3_NestedNestedMsg3 {
	if m != nil {
		return m.NNM
	}
	return nil
}

func (m *NestedDefinition3) GetNM() *NestedDefinition3_NestedMessage3 {
	if m != nil {
		return m.NM
	}
	return nil
}

type NestedDefinition3_NestedMessage3 struct {
	NestedField1 uint64                                             `protobuf:"fixed64,1,opt,name=NestedField1,proto3" json:"NestedField1,omitempty"`
	NNM          *NestedDefinition3_NestedMessage3_NestedNestedMsg3 `protobuf:"bytes,2,opt,name=NNM" json:"NNM,omitempty"`
}

func (m *NestedDefinition3_NestedMessage3) Reset()         { *m = NestedDefinition3_NestedMessage3{} }
func (m *NestedDefinition3_NestedMessage3) String() string { return proto.CompactTextString(m) }
func (*NestedDefinition3_NestedMessage3) ProtoMessage()    {}

func (m *NestedDefinition3_NestedMessage3) GetNNM() *NestedDefinition3_NestedMessage3_NestedNestedMsg3 {
	if m != nil {
		return m.NNM
	}
	return nil
}

type NestedDefinition3_NestedMessage3_NestedNestedMsg3 struct {
	NestedNestedField1 string `protobuf:"bytes,10,opt,name=NestedNestedField1,proto3" json:"NestedNestedField1,omitempty"`
}

func (m *NestedDefinition3_NestedMessage3_NestedNestedMsg3) Reset() {
	*m = NestedDefinition3_NestedMessage3_NestedNestedMsg3{}
}
func (m *NestedDefinition3_NestedMessage3_NestedNestedMsg3) String() string {
	return proto.CompactTextString(m)
}
func (*NestedDefinition3_NestedMessage3_NestedNestedMsg3) ProtoMessage() {}

type NestedScope3 struct {
	A *NestedDefinition3_NestedMessage3_NestedNestedMsg3 `protobuf:"bytes,1,opt,name=A" json:"A,omitempty"`
	B NestedDefinition3_NestedEnum3                      `protobuf:"varint,2,opt,name=B,proto3,enum=fuzztests.NestedDefinition3_NestedEnum3" json:"B,omitempty"`
	C *NestedDefinition3_NestedMessage3                  `protobuf:"bytes,3,opt,name=C" json:"C,omitempty"`
}

func (m *NestedScope3) Reset()         { *m = NestedScope3{} }
func (m *NestedScope3) String() string { return proto.CompactTextString(m) }
func (*NestedScope3) ProtoMessage()    {}

func (m *NestedScope3) GetA() *NestedDefinition3_NestedMessage3_NestedNestedMsg3 {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *NestedScope3) GetC() *NestedDefinition3_NestedMessage3 {
	if m != nil {
		return m.C
	}
	return nil
}

func init() {
	proto.RegisterEnum("fuzztests.TheTestEnum3", TheTestEnum3_name, TheTestEnum3_value)
	proto.RegisterEnum("fuzztests.NestedDefinition3_NestedEnum3", NestedDefinition3_NestedEnum3_name, NestedDefinition3_NestedEnum3_value)
}
func (m *NinOptNative3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinOptNative3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field1 != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Fuzz3(data, i, uint64(math.Float64bits(m.Field1)))
	}
	if m.Field2 != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Fuzz3(data, i, uint32(math.Float32bits(m.Field2)))
	}
	if m.Field3 != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field3))
	}
	if m.Field4 != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field4))
	}
	if m.Field5 != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field5))
	}
	if m.Field6 != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field6))
	}
	if m.Field7 != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintFuzz3(data, i, uint64((uint32(m.Field7)<<1)^uint32((m.Field7>>31))))
	}
	if m.Field8 != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintFuzz3(data, i, uint64((uint64(m.Field8)<<1)^uint64((m.Field8>>63))))
	}
	if m.Field9 != 0 {
		data[i] = 0x4d
		i++
		i = encodeFixed32Fuzz3(data, i, uint32(m.Field9))
	}
	if m.Field10 != 0 {
		data[i] = 0x55
		i++
		i = encodeFixed32Fuzz3(data, i, uint32(m.Field10))
	}
	if m.Field11 != 0 {
		data[i] = 0x59
		i++
		i = encodeFixed64Fuzz3(data, i, uint64(m.Field11))
	}
	if m.Field12 != 0 {
		data[i] = 0x61
		i++
		i = encodeFixed64Fuzz3(data, i, uint64(m.Field12))
	}
	if m.Field13 {
		data[i] = 0x68
		i++
		if m.Field13 {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Field14) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field14)))
		i += copy(data[i:], m.Field14)
	}
	if m.Field15 != nil {
		if len(m.Field15) > 0 {
			data[i] = 0x7a
			i++
			i = encodeVarintFuzz3(data, i, uint64(len(m.Field15)))
			i += copy(data[i:], m.Field15)
		}
	}
	return i, nil
}

func (m *NinRepNative3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinRepNative3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field1) > 0 {
		for _, num := range m.Field1 {
			data[i] = 0x9
			i++
			f1 := math.Float64bits(num)
			data[i] = uint8(f1)
			i++
			data[i] = uint8(f1 >> 8)
			i++
			data[i] = uint8(f1 >> 16)
			i++
			data[i] = uint8(f1 >> 24)
			i++
			data[i] = uint8(f1 >> 32)
			i++
			data[i] = uint8(f1 >> 40)
			i++
			data[i] = uint8(f1 >> 48)
			i++
			data[i] = uint8(f1 >> 56)
			i++
		}
	}
	if len(m.Field2) > 0 {
		for _, num := range m.Field2 {
			data[i] = 0x15
			i++
			f2 := math.Float32bits(num)
			data[i] = uint8(f2)
			i++
			data[i] = uint8(f2 >> 8)
			i++
			data[i] = uint8(f2 >> 16)
			i++
			data[i] = uint8(f2 >> 24)
			i++
		}
	}
	if len(m.Field3) > 0 {
		for _, num := range m.Field3 {
			data[i] = 0x18
			i++
			i = encodeVarintFuzz3(data, i, uint64(num))
		}
	}
	if len(m.Field4) > 0 {
		for _, num := range m.Field4 {
			data[i] = 0x20
			i++
			i = encodeVarintFuzz3(data, i, uint64(num))
		}
	}
	if len(m.Field5) > 0 {
		for _, num := range m.Field5 {
			data[i] = 0x28
			i++
			i = encodeVarintFuzz3(data, i, uint64(num))
		}
	}
	if len(m.Field6) > 0 {
		for _, num := range m.Field6 {
			data[i] = 0x30
			i++
			i = encodeVarintFuzz3(data, i, uint64(num))
		}
	}
	if len(m.Field7) > 0 {
		for _, num := range m.Field7 {
			data[i] = 0x38
			i++
			x3 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x3 >= 1<<7 {
				data[i] = uint8(uint64(x3)&0x7f | 0x80)
				x3 >>= 7
				i++
			}
			data[i] = uint8(x3)
			i++
		}
	}
	if len(m.Field8) > 0 {
		for _, num := range m.Field8 {
			data[i] = 0x40
			i++
			x4 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x4 >= 1<<7 {
				data[i] = uint8(uint64(x4)&0x7f | 0x80)
				x4 >>= 7
				i++
			}
			data[i] = uint8(x4)
			i++
		}
	}
	if len(m.Field9) > 0 {
		for _, num := range m.Field9 {
			data[i] = 0x4d
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.Field10) > 0 {
		for _, num := range m.Field10 {
			data[i] = 0x55
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.Field11) > 0 {
		for _, num := range m.Field11 {
			data[i] = 0x59
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Field12) > 0 {
		for _, num := range m.Field12 {
			data[i] = 0x61
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Field13) > 0 {
		for _, b := range m.Field13 {
			data[i] = 0x68
			i++
			if b {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	if len(m.Field14) > 0 {
		for _, s := range m.Field14 {
			data[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Field15) > 0 {
		for _, b := range m.Field15 {
			data[i] = 0x7a
			i++
			i = encodeVarintFuzz3(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	return i, nil
}

func (m *NinRepPackedNative3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinRepPackedNative3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field1) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field1)*8))
		for _, num := range m.Field1 {
			f5 := math.Float64bits(num)
			data[i] = uint8(f5)
			i++
			data[i] = uint8(f5 >> 8)
			i++
			data[i] = uint8(f5 >> 16)
			i++
			data[i] = uint8(f5 >> 24)
			i++
			data[i] = uint8(f5 >> 32)
			i++
			data[i] = uint8(f5 >> 40)
			i++
			data[i] = uint8(f5 >> 48)
			i++
			data[i] = uint8(f5 >> 56)
			i++
		}
	}
	if len(m.Field2) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field2)*4))
		for _, num := range m.Field2 {
			f6 := math.Float32bits(num)
			data[i] = uint8(f6)
			i++
			data[i] = uint8(f6 >> 8)
			i++
			data[i] = uint8(f6 >> 16)
			i++
			data[i] = uint8(f6 >> 24)
			i++
		}
	}
	if len(m.Field3) > 0 {
		data8 := make([]byte, len(m.Field3)*10)
		var j7 int
		for _, num1 := range m.Field3 {
			num := uint64(num1)
			for num >= 1<<7 {
				data8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			data8[j7] = uint8(num)
			j7++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintFuzz3(data, i, uint64(j7))
		i += copy(data[i:], data8[:j7])
	}
	if len(m.Field4) > 0 {
		data10 := make([]byte, len(m.Field4)*10)
		var j9 int
		for _, num1 := range m.Field4 {
			num := uint64(num1)
			for num >= 1<<7 {
				data10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			data10[j9] = uint8(num)
			j9++
		}
		data[i] = 0x22
		i++
		i = encodeVarintFuzz3(data, i, uint64(j9))
		i += copy(data[i:], data10[:j9])
	}
	if len(m.Field5) > 0 {
		data12 := make([]byte, len(m.Field5)*10)
		var j11 int
		for _, num := range m.Field5 {
			for num >= 1<<7 {
				data12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			data12[j11] = uint8(num)
			j11++
		}
		data[i] = 0x2a
		i++
		i = encodeVarintFuzz3(data, i, uint64(j11))
		i += copy(data[i:], data12[:j11])
	}
	if len(m.Field6) > 0 {
		data14 := make([]byte, len(m.Field6)*10)
		var j13 int
		for _, num := range m.Field6 {
			for num >= 1<<7 {
				data14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			data14[j13] = uint8(num)
			j13++
		}
		data[i] = 0x32
		i++
		i = encodeVarintFuzz3(data, i, uint64(j13))
		i += copy(data[i:], data14[:j13])
	}
	if len(m.Field7) > 0 {
		data15 := make([]byte, len(m.Field7)*5)
		var j16 int
		for _, num := range m.Field7 {
			x17 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x17 >= 1<<7 {
				data15[j16] = uint8(uint64(x17)&0x7f | 0x80)
				j16++
				x17 >>= 7
			}
			data15[j16] = uint8(x17)
			j16++
		}
		data[i] = 0x3a
		i++
		i = encodeVarintFuzz3(data, i, uint64(j16))
		i += copy(data[i:], data15[:j16])
	}
	if len(m.Field8) > 0 {
		var j18 int
		data20 := make([]byte, len(m.Field8)*10)
		for _, num := range m.Field8 {
			x19 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x19 >= 1<<7 {
				data20[j18] = uint8(uint64(x19)&0x7f | 0x80)
				j18++
				x19 >>= 7
			}
			data20[j18] = uint8(x19)
			j18++
		}
		data[i] = 0x42
		i++
		i = encodeVarintFuzz3(data, i, uint64(j18))
		i += copy(data[i:], data20[:j18])
	}
	if len(m.Field9) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field9)*4))
		for _, num := range m.Field9 {
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.Field10) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field10)*4))
		for _, num := range m.Field10 {
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.Field11) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field11)*8))
		for _, num := range m.Field11 {
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Field12) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field12)*8))
		for _, num := range m.Field12 {
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Field13) > 0 {
		data[i] = 0x6a
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field13)))
		for _, b := range m.Field13 {
			if b {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *NinOptStruct3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinOptStruct3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field1 != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Fuzz3(data, i, uint64(math.Float64bits(m.Field1)))
	}
	if m.Field2 != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Fuzz3(data, i, uint32(math.Float32bits(m.Field2)))
	}
	if m.Field3 != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field3.Size()))
		n21, err := m.Field3.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Field4 != nil {
		data[i] = 0x22
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field4.Size()))
		n22, err := m.Field4.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Field6 != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field6))
	}
	if m.Field7 != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintFuzz3(data, i, uint64((uint32(m.Field7)<<1)^uint32((m.Field7>>31))))
	}
	if m.Field8 != nil {
		data[i] = 0x42
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field8.Size()))
		n23, err := m.Field8.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Field13 {
		data[i] = 0x68
		i++
		if m.Field13 {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Field14) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.Field14)))
		i += copy(data[i:], m.Field14)
	}
	if m.Field15 != nil {
		if len(m.Field15) > 0 {
			data[i] = 0x7a
			i++
			i = encodeVarintFuzz3(data, i, uint64(len(m.Field15)))
			i += copy(data[i:], m.Field15)
		}
	}
	return i, nil
}

func (m *NinRepStruct3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinRepStruct3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field1) > 0 {
		for _, num := range m.Field1 {
			data[i] = 0x9
			i++
			f24 := math.Float64bits(num)
			data[i] = uint8(f24)
			i++
			data[i] = uint8(f24 >> 8)
			i++
			data[i] = uint8(f24 >> 16)
			i++
			data[i] = uint8(f24 >> 24)
			i++
			data[i] = uint8(f24 >> 32)
			i++
			data[i] = uint8(f24 >> 40)
			i++
			data[i] = uint8(f24 >> 48)
			i++
			data[i] = uint8(f24 >> 56)
			i++
		}
	}
	if len(m.Field2) > 0 {
		for _, num := range m.Field2 {
			data[i] = 0x15
			i++
			f25 := math.Float32bits(num)
			data[i] = uint8(f25)
			i++
			data[i] = uint8(f25 >> 8)
			i++
			data[i] = uint8(f25 >> 16)
			i++
			data[i] = uint8(f25 >> 24)
			i++
		}
	}
	if len(m.Field3) > 0 {
		for _, msg := range m.Field3 {
			data[i] = 0x1a
			i++
			i = encodeVarintFuzz3(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Field4) > 0 {
		for _, msg := range m.Field4 {
			data[i] = 0x22
			i++
			i = encodeVarintFuzz3(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Field6) > 0 {
		for _, num := range m.Field6 {
			data[i] = 0x30
			i++
			i = encodeVarintFuzz3(data, i, uint64(num))
		}
	}
	if len(m.Field7) > 0 {
		for _, num := range m.Field7 {
			data[i] = 0x38
			i++
			x26 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x26 >= 1<<7 {
				data[i] = uint8(uint64(x26)&0x7f | 0x80)
				x26 >>= 7
				i++
			}
			data[i] = uint8(x26)
			i++
		}
	}
	if len(m.Field8) > 0 {
		for _, msg := range m.Field8 {
			data[i] = 0x42
			i++
			i = encodeVarintFuzz3(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Field13) > 0 {
		for _, b := range m.Field13 {
			data[i] = 0x68
			i++
			if b {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	if len(m.Field14) > 0 {
		for _, s := range m.Field14 {
			data[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Field15) > 0 {
		for _, b := range m.Field15 {
			data[i] = 0x7a
			i++
			i = encodeVarintFuzz3(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	return i, nil
}

func (m *NinNestedStruct3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinNestedStruct3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field1 != nil {
		data[i] = 0xa
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field1.Size()))
		n27, err := m.Field1.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Field2) > 0 {
		for _, msg := range m.Field2 {
			data[i] = 0x12
			i++
			i = encodeVarintFuzz3(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Nil3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Nil3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NinOptEnum3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinOptEnum3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field1 != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field1))
	}
	return i, nil
}

func (m *NinRepEnum3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NinRepEnum3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field1) > 0 {
		for _, num := range m.Field1 {
			data[i] = 0x8
			i++
			i = encodeVarintFuzz3(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *NestedDefinition3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NestedDefinition3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field1 != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.Field1))
	}
	if m.EnumField != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.EnumField))
	}
	if m.NNM != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.NNM.Size()))
		n28, err := m.NNM.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.NM != nil {
		data[i] = 0x22
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.NM.Size()))
		n29, err := m.NM.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *NestedDefinition3_NestedMessage3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NestedDefinition3_NestedMessage3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NestedField1 != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Fuzz3(data, i, uint64(m.NestedField1))
	}
	if m.NNM != nil {
		data[i] = 0x12
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.NNM.Size()))
		n30, err := m.NNM.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *NestedDefinition3_NestedMessage3_NestedNestedMsg3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NestedDefinition3_NestedMessage3_NestedNestedMsg3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NestedNestedField1) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintFuzz3(data, i, uint64(len(m.NestedNestedField1)))
		i += copy(data[i:], m.NestedNestedField1)
	}
	return i, nil
}

func (m *NestedScope3) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NestedScope3) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		data[i] = 0xa
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.A.Size()))
		n31, err := m.A.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.B != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.B))
	}
	if m.C != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintFuzz3(data, i, uint64(m.C.Size()))
		n32, err := m.C.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func encodeFixed64Fuzz3(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Fuzz3(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFuzz3(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *NinOptNative3) Size() (n int) {
	var l int
	_ = l
	if m.Field1 != 0 {
		n += 9
	}
	if m.Field2 != 0 {
		n += 5
	}
	if m.Field3 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field3))
	}
	if m.Field4 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field4))
	}
	if m.Field5 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field5))
	}
	if m.Field6 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field6))
	}
	if m.Field7 != 0 {
		n += 1 + sozFuzz3(uint64(m.Field7))
	}
	if m.Field8 != 0 {
		n += 1 + sozFuzz3(uint64(m.Field8))
	}
	if m.Field9 != 0 {
		n += 5
	}
	if m.Field10 != 0 {
		n += 5
	}
	if m.Field11 != 0 {
		n += 9
	}
	if m.Field12 != 0 {
		n += 9
	}
	if m.Field13 {
		n += 2
	}
	l = len(m.Field14)
	if l > 0 {
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.Field15 != nil {
		l = len(m.Field15)
		if l > 0 {
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	return n
}

func (m *NinRepNative3) Size() (n int) {
	var l int
	_ = l
	if len(m.Field1) > 0 {
		n += 9 * len(m.Field1)
	}
	if len(m.Field2) > 0 {
		n += 5 * len(m.Field2)
	}
	if len(m.Field3) > 0 {
		for _, e := range m.Field3 {
			n += 1 + sovFuzz3(uint64(e))
		}
	}
	if len(m.Field4) > 0 {
		for _, e := range m.Field4 {
			n += 1 + sovFuzz3(uint64(e))
		}
	}
	if len(m.Field5) > 0 {
		for _, e := range m.Field5 {
			n += 1 + sovFuzz3(uint64(e))
		}
	}
	if len(m.Field6) > 0 {
		for _, e := range m.Field6 {
			n += 1 + sovFuzz3(uint64(e))
		}
	}
	if len(m.Field7) > 0 {
		for _, e := range m.Field7 {
			n += 1 + sozFuzz3(uint64(e))
		}
	}
	if len(m.Field8) > 0 {
		for _, e := range m.Field8 {
			n += 1 + sozFuzz3(uint64(e))
		}
	}
	if len(m.Field9) > 0 {
		n += 5 * len(m.Field9)
	}
	if len(m.Field10) > 0 {
		n += 5 * len(m.Field10)
	}
	if len(m.Field11) > 0 {
		n += 9 * len(m.Field11)
	}
	if len(m.Field12) > 0 {
		n += 9 * len(m.Field12)
	}
	if len(m.Field13) > 0 {
		n += 2 * len(m.Field13)
	}
	if len(m.Field14) > 0 {
		for _, s := range m.Field14 {
			l = len(s)
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	if len(m.Field15) > 0 {
		for _, b := range m.Field15 {
			l = len(b)
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	return n
}

func (m *NinRepPackedNative3) Size() (n int) {
	var l int
	_ = l
	if len(m.Field1) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field1)*8)) + len(m.Field1)*8
	}
	if len(m.Field2) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field2)*4)) + len(m.Field2)*4
	}
	if len(m.Field3) > 0 {
		l = 0
		for _, e := range m.Field3 {
			l += sovFuzz3(uint64(e))
		}
		n += 1 + sovFuzz3(uint64(l)) + l
	}
	if len(m.Field4) > 0 {
		l = 0
		for _, e := range m.Field4 {
			l += sovFuzz3(uint64(e))
		}
		n += 1 + sovFuzz3(uint64(l)) + l
	}
	if len(m.Field5) > 0 {
		l = 0
		for _, e := range m.Field5 {
			l += sovFuzz3(uint64(e))
		}
		n += 1 + sovFuzz3(uint64(l)) + l
	}
	if len(m.Field6) > 0 {
		l = 0
		for _, e := range m.Field6 {
			l += sovFuzz3(uint64(e))
		}
		n += 1 + sovFuzz3(uint64(l)) + l
	}
	if len(m.Field7) > 0 {
		l = 0
		for _, e := range m.Field7 {
			l += sozFuzz3(uint64(e))
		}
		n += 1 + sovFuzz3(uint64(l)) + l
	}
	if len(m.Field8) > 0 {
		l = 0
		for _, e := range m.Field8 {
			l += sozFuzz3(uint64(e))
		}
		n += 1 + sovFuzz3(uint64(l)) + l
	}
	if len(m.Field9) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field9)*4)) + len(m.Field9)*4
	}
	if len(m.Field10) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field10)*4)) + len(m.Field10)*4
	}
	if len(m.Field11) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field11)*8)) + len(m.Field11)*8
	}
	if len(m.Field12) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field12)*8)) + len(m.Field12)*8
	}
	if len(m.Field13) > 0 {
		n += 1 + sovFuzz3(uint64(len(m.Field13))) + len(m.Field13)*1
	}
	return n
}

func (m *NinOptStruct3) Size() (n int) {
	var l int
	_ = l
	if m.Field1 != 0 {
		n += 9
	}
	if m.Field2 != 0 {
		n += 5
	}
	if m.Field3 != nil {
		l = m.Field3.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.Field4 != nil {
		l = m.Field4.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.Field6 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field6))
	}
	if m.Field7 != 0 {
		n += 1 + sozFuzz3(uint64(m.Field7))
	}
	if m.Field8 != nil {
		l = m.Field8.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.Field13 {
		n += 2
	}
	l = len(m.Field14)
	if l > 0 {
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.Field15 != nil {
		l = len(m.Field15)
		if l > 0 {
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	return n
}

func (m *NinRepStruct3) Size() (n int) {
	var l int
	_ = l
	if len(m.Field1) > 0 {
		n += 9 * len(m.Field1)
	}
	if len(m.Field2) > 0 {
		n += 5 * len(m.Field2)
	}
	if len(m.Field3) > 0 {
		for _, e := range m.Field3 {
			l = e.Size()
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	if len(m.Field4) > 0 {
		for _, e := range m.Field4 {
			l = e.Size()
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	if len(m.Field6) > 0 {
		for _, e := range m.Field6 {
			n += 1 + sovFuzz3(uint64(e))
		}
	}
	if len(m.Field7) > 0 {
		for _, e := range m.Field7 {
			n += 1 + sozFuzz3(uint64(e))
		}
	}
	if len(m.Field8) > 0 {
		for _, e := range m.Field8 {
			l = e.Size()
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	if len(m.Field13) > 0 {
		n += 2 * len(m.Field13)
	}
	if len(m.Field14) > 0 {
		for _, s := range m.Field14 {
			l = len(s)
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	if len(m.Field15) > 0 {
		for _, b := range m.Field15 {
			l = len(b)
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	return n
}

func (m *NinNestedStruct3) Size() (n int) {
	var l int
	_ = l
	if m.Field1 != nil {
		l = m.Field1.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if len(m.Field2) > 0 {
		for _, e := range m.Field2 {
			l = e.Size()
			n += 1 + l + sovFuzz3(uint64(l))
		}
	}
	return n
}

func (m *Nil3) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NinOptEnum3) Size() (n int) {
	var l int
	_ = l
	if m.Field1 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field1))
	}
	return n
}

func (m *NinRepEnum3) Size() (n int) {
	var l int
	_ = l
	if len(m.Field1) > 0 {
		for _, e := range m.Field1 {
			n += 1 + sovFuzz3(uint64(e))
		}
	}
	return n
}

func (m *NestedDefinition3) Size() (n int) {
	var l int
	_ = l
	if m.Field1 != 0 {
		n += 1 + sovFuzz3(uint64(m.Field1))
	}
	if m.EnumField != 0 {
		n += 1 + sovFuzz3(uint64(m.EnumField))
	}
	if m.NNM != nil {
		l = m.NNM.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.NM != nil {
		l = m.NM.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	return n
}

func (m *NestedDefinition3_NestedMessage3) Size() (n int) {
	var l int
	_ = l
	if m.NestedField1 != 0 {
		n += 9
	}
	if m.NNM != nil {
		l = m.NNM.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	return n
}

func (m *NestedDefinition3_NestedMessage3_NestedNestedMsg3) Size() (n int) {
	var l int
	_ = l
	l = len(m.NestedNestedField1)
	if l > 0 {
		n += 1 + l + sovFuzz3(uint64(l))
	}
	return n
}

func (m *NestedScope3) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	if m.B != 0 {
		n += 1 + sovFuzz3(uint64(m.B))
	}
	if m.C != nil {
		l = m.C.Size()
		n += 1 + l + sovFuzz3(uint64(l))
	}
	return n
}

func sovFuzz3(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFuzz3(x uint64) (n int) {
	return sovFuzz3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NinOptNative3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Field1 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Field2 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
			m.Field3 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field3 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
			m.Field4 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field4 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
			m.Field5 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field5 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
			m.Field6 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field6 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Field7 = v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Field8 = int64(v)
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
			m.Field9 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Field9 = uint32(data[iNdEx-4])
			m.Field9 |= uint32(data[iNdEx-3]) << 8
			m.Field9 |= uint32(data[iNdEx-2]) << 16
			m.Field9 |= uint32(data[iNdEx-1]) << 24
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
			m.Field10 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Field10 = int32(data[iNdEx-4])
			m.Field10 |= int32(data[iNdEx-3]) << 8
			m.Field10 |= int32(data[iNdEx-2]) << 16
			m.Field10 |= int32(data[iNdEx-1]) << 24
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
			m.Field11 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Field11 = uint64(data[iNdEx-8])
			m.Field11 |= uint64(data[iNdEx-7]) << 8
			m.Field11 |= uint64(data[iNdEx-6]) << 16
			m.Field11 |= uint64(data[iNdEx-5]) << 24
			m.Field11 |= uint64(data[iNdEx-4]) << 32
			m.Field11 |= uint64(data[iNdEx-3]) << 40
			m.Field11 |= uint64(data[iNdEx-2]) << 48
			m.Field11 |= uint64(data[iNdEx-1]) << 56
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
			m.Field12 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Field12 = int64(data[iNdEx-8])
			m.Field12 |= int64(data[iNdEx-7]) << 8
			m.Field12 |= int64(data[iNdEx-6]) << 16
			m.Field12 |= int64(data[iNdEx-5]) << 24
			m.Field12 |= int64(data[iNdEx-4]) << 32
			m.Field12 |= int64(data[iNdEx-3]) << 40
			m.Field12 |= int64(data[iNdEx-2]) << 48
			m.Field12 |= int64(data[iNdEx-1]) << 56
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field13 = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field14", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field14 = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field15", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field15 = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinRepNative3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Field1 = append(m.Field1, v2)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			v2 := float32(math.Float32frombits(v))
			m.Field2 = append(m.Field2, v2)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field3 = append(m.Field3, v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field4 = append(m.Field4, v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field5 = append(m.Field5, v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field6 = append(m.Field6, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Field7 = append(m.Field7, v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Field8 = append(m.Field8, int64(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Field9 = append(m.Field9, v)
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = int32(data[iNdEx-4])
			v |= int32(data[iNdEx-3]) << 8
			v |= int32(data[iNdEx-2]) << 16
			v |= int32(data[iNdEx-1]) << 24
			m.Field10 = append(m.Field10, v)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Field11 = append(m.Field11, v)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = int64(data[iNdEx-8])
			v |= int64(data[iNdEx-7]) << 8
			v |= int64(data[iNdEx-6]) << 16
			v |= int64(data[iNdEx-5]) << 24
			v |= int64(data[iNdEx-4]) << 32
			v |= int64(data[iNdEx-3]) << 40
			v |= int64(data[iNdEx-2]) << 48
			v |= int64(data[iNdEx-1]) << 56
			m.Field12 = append(m.Field12, v)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field13 = append(m.Field13, bool(v != 0))
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field14", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field14 = append(m.Field14, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field15", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field15 = append(m.Field15, make([]byte, postIndex-iNdEx))
			copy(m.Field15[len(m.Field15)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinRepPackedNative3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Field1 = append(m.Field1, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Field1 = append(m.Field1, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(data[iNdEx-4])
					v |= uint32(data[iNdEx-3]) << 8
					v |= uint32(data[iNdEx-2]) << 16
					v |= uint32(data[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Field2 = append(m.Field2, v2)
				}
			} else if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(data[iNdEx-4])
				v |= uint32(data[iNdEx-3]) << 8
				v |= uint32(data[iNdEx-2]) << 16
				v |= uint32(data[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Field2 = append(m.Field2, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(data[iNdEx-4])
					v |= uint32(data[iNdEx-3]) << 8
					v |= uint32(data[iNdEx-2]) << 16
					v |= uint32(data[iNdEx-1]) << 24
					m.Field9 = append(m.Field9, v)
				}
			} else if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(data[iNdEx-4])
				v |= uint32(data[iNdEx-3]) << 8
				v |= uint32(data[iNdEx-2]) << 16
				v |= uint32(data[iNdEx-1]) << 24
				m.Field9 = append(m.Field9, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = int32(data[iNdEx-4])
					v |= int32(data[iNdEx-3]) << 8
					v |= int32(data[iNdEx-2]) << 16
					v |= int32(data[iNdEx-1]) << 24
					m.Field10 = append(m.Field10, v)
				}
			} else if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = int32(data[iNdEx-4])
				v |= int32(data[iNdEx-3]) << 8
				v |= int32(data[iNdEx-2]) << 16
				v |= int32(data[iNdEx-1]) << 24
				m.Field10 = append(m.Field10, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					m.Field11 = append(m.Field11, v)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				m.Field11 = append(m.Field11, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = int64(data[iNdEx-8])
					v |= int64(data[iNdEx-7]) << 8
					v |= int64(data[iNdEx-6]) << 16
					v |= int64(data[iNdEx-5]) << 24
					v |= int64(data[iNdEx-4]) << 32
					v |= int64(data[iNdEx-3]) << 40
					v |= int64(data[iNdEx-2]) << 48
					v |= int64(data[iNdEx-1]) << 56
					m.Field12 = append(m.Field12, v)
				}
			} else if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = int64(data[iNdEx-8])
				v |= int64(data[iNdEx-7]) << 8
				v |= int64(data[iNdEx-6]) << 16
				v |= int64(data[iNdEx-5]) << 24
				v |= int64(data[iNdEx-4]) << 32
				v |= int64(data[iNdEx-3]) << 40
				v |= int64(data[iNdEx-2]) << 48
				v |= int64(data[iNdEx-1]) << 56
				m.Field12 = append(m.Field12, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFuzz3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinOptStruct3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Field1 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Field2 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field3 == nil {
				m.Field3 = &NinOptNative3{}
			}
			if err := m.Field3.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field4 == nil {
				m.Field4 = &NinOptNative3{}
			}
			if err := m.Field4.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
			m.Field6 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field6 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Field7 = v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field8 == nil {
				m.Field8 = &NinOptNative3{}
			}
			if err := m.Field8.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field13 = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field14", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field14 = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field15", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field15 = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinRepStruct3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Field1 = append(m.Field1, v2)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			v2 := float32(math.Float32frombits(v))
			m.Field2 = append(m.Field2, v2)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field3 = append(m.Field3, &NinOptNative3{})
			if err := m.Field3[len(m.Field3)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field4 = append(m.Field4, &NinOptNative3{})
			if err := m.Field4[len(m.Field4)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field6 = append(m.Field6, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Field7 = append(m.Field7, v)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field8 = append(m.Field8, &NinOptNative3{})
			if err := m.Field8[len(m.Field8)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field13 = append(m.Field13, bool(v != 0))
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field14", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field14 = append(m.Field14, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field15", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field15 = append(m.Field15, make([]byte, postIndex-iNdEx))
			copy(m.Field15[len(m.Field15)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinNestedStruct3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field1 == nil {
				m.Field1 = &NinOptStruct3{}
			}
			if err := m.Field1.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field2 = append(m.Field2, &NinRepStruct3{})
			if err := m.Field2[len(m.Field2)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Nil3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinOptEnum3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			m.Field1 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field1 |= (TheTestEnum3(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NinRepEnum3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v TheTestEnum3
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (TheTestEnum3(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field1 = append(m.Field1, v)
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NestedDefinition3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			m.Field1 = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Field1 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumField", wireType)
			}
			m.EnumField = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EnumField |= (NestedDefinition3_NestedEnum3(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NNM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NNM == nil {
				m.NNM = &NestedDefinition3_NestedMessage3_NestedNestedMsg3{}
			}
			if err := m.NNM.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NM == nil {
				m.NM = &NestedDefinition3_NestedMessage3{}
			}
			if err := m.NM.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NestedDefinition3_NestedMessage3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NestedField1", wireType)
			}
			m.NestedField1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.NestedField1 = uint64(data[iNdEx-8])
			m.NestedField1 |= uint64(data[iNdEx-7]) << 8
			m.NestedField1 |= uint64(data[iNdEx-6]) << 16
			m.NestedField1 |= uint64(data[iNdEx-5]) << 24
			m.NestedField1 |= uint64(data[iNdEx-4]) << 32
			m.NestedField1 |= uint64(data[iNdEx-3]) << 40
			m.NestedField1 |= uint64(data[iNdEx-2]) << 48
			m.NestedField1 |= uint64(data[iNdEx-1]) << 56
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NNM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NNM == nil {
				m.NNM = &NestedDefinition3_NestedMessage3_NestedNestedMsg3{}
			}
			if err := m.NNM.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NestedDefinition3_NestedMessage3_NestedNestedMsg3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NestedNestedField1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NestedNestedField1 = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NestedScope3) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedDefinition3_NestedMessage3_NestedNestedMsg3{}
			}
			if err := m.A.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.B |= (NestedDefinition3_NestedEnum3(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFuzz3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C == nil {
				m.C = &NestedDefinition3_NestedMessage3{}
			}
			if err := m.C.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipFuzz3(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFuzz3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func skipFuzz3(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFuzz3
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFuzz3(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFuzz3 = fmt.Errorf("proto: negative length found during unmarshaling")
)
